| Лабораторная работа №2     |  24Б10                      | Архитектура компьютера |
| :------------------------- | --------------------------- | ---------------------- |
| Построение логических схем | Согоян Вазген Айкович       | 2024                   |

## Инструментарий
> Указываем свою версию icarus verilog

## Вариант
> Указываем что было выполнено.

# Описание

### Теоретические обоснования

Назовем крайними случаями следующие входы:
- $\sqrt{+\infty} = +\infty$
- $\sqrt{-\infty} = \mathrm{qNaN}$
- $\sqrt{\text{-nonzero}} = \mathrm{qNaN}$
- $\sqrt{\pm 0} = \pm 0$
- $\sqrt{\mathrm{NaN}}$ = тот же NaN, но «утихомиренный»

В любом другом случае на вход получаем положительное число x: +0 < x < +inf.
Оно может быть денорм или норм.
Рассмотрим корень из минимального денорм числа:
$\sqrt{2^{-24}} = 2^{-12}$ - нормальное. Это хорошо. Для любого некрайнего случая ответ нормальный.

Поймем следующий факт: 
Старшая единица числа M на 10 бите (начиная с нуля) <=> старшая единица числа M^2 на 20 или 21 бите.
Так как 
$$
2^{10} \le M < 2^{11}
\;\Longleftrightarrow\;
2^{20} \le M^2 < 2^{22}
$$


1. Нормальное число

$ 1.M \cdot 2^{E-15} $ - фактическое число, которое записано в half precision как 0EM (E - 5 бит, M - 10 бит).

$$
\sqrt{1.M \cdot 2^{E-15}} =
\sqrt{1.M}\cdot 2^{(E-15)/2} =
\sqrt{1.M}\cdot 2^{(E+15)/2 - 15}
$$

Тогда если E будет четно, мы вычтем из E единицу и сдвигаем мантиссу. И все хорошо. 

Экспонента результата (сдвинутая) будет иметь вид (E-1)/2 + 8

Мантиссу результата считаем так:
- приписываем 10 нулей в конец числа
- получаем число длиной 21-22 бита
- берем корень итеративно из этого число
- получаем число длиной 11 бит, старшая единица попадает в старшее место
- убираем старшую единицы и эти 10 бит записываем в мантиссу ответа

2. Денормальное число

$ 0.M \cdot 2^{-14} = M \cdot 2^{-24} $ - фактическое число.

Нормализуем экспоненту и мантиссу.
Возвращаясь в структурное программирование, алгоритм действий таков:
```cpp
e = 1;
while (10 бит (начиная с нуля) равен 0) {
    m <<= 1;
    e--;
}
```

Чтобы всегда оставаться в unsigned числах, делаю я чуть другое.
- в схемах нахожу место старшего бита мантиссы (создал специальную схему для этого, легко)
- рассчитываю, насколько сдвинуть мантиссу нужно - пусть будет shift
  - то есть для мантиссы 0010010110 нужно получить 10010110000
  - в данном случае shift = 3, а старшая единица изначально была на месте 7
- экспонента итоговая будет равна 8 - shift/2
- тогда нужно держать shift четным:
  - если shift нечетный, то прибавим в shift единицу и сдвинем мантиссу влево
- мантиссу считем так же: приписываем 10 нулей и берем корень

### Logisim

**sum**

Реализованы полные сумматоры чисел 1битных, 2, 4, 8, 16, 32 (через друг друга).

**memory**

Реализован синхронный RS триггер. Так же, как рассматривали на лекции. При этом добавлен еще один вход ENABLE: когда он равен 1, триггер работает как должен. При ENABLE=0 внутреннее состояние триггера сбрасывается в 0, изменения остальных входов ни на что не влияет.

Далее реализовал обычный D триггер, то есть работающий по уровню. После этого, подключив два D триггера подряд, получил триггер, работающий по фронту. Все это реализовано стандратно, просто с дополнительным входом ENABLE, который просто подключается в RS триггер.

Далее реализовано блоки памяти в 2, 4, 8, 16, 32 бита (через друг друга). Эти блоки памяти созданы по два, один по уровню, второй по фронту (почти везде нужно по фронту, но в одном месте пригодилось по уровню).

При этом ENABLE в памяти работаем асинхронно (кажется, я ничего не путаю и использую правильное слово). То перевод ENABLE из 1 в 0 или из 0 в 1 можно никак не синхронизировать с CLK и все будет корректно работать. 

**нахождение старшего бита**

Эти подсхемы назвал highest bit, не знаю, как правильно это называть. Они есть на входы 2 бита, 4, 8, 16, вновь большие сделаны через меньшие.

На 2 бита реализован просто: банально возвращает второй бит. То есть след смысл: когда ответ 0, значит, что старший бит на 0 месте, а когда 1, значит старшим на месте 1 (то есть на втором бите).

На 4 бита разбиваем их на 2 старших и 2 младших, считая для каждой пары место их старшего бита. Тогда если 2 старших бита сами по себе равны 0, то возвращаем ответ на 2 младших, иначе возвращаем ответ на 2 старших, к которому прибавили число 2 (тут, конечно, используется мультиплексор, о чем ниже).

На большее колво битов делается так же.

**Мультиплексоры**

У меня реализовано лишь два мультиплексора, оба реализуют выбор лишь между двумя значениями. Первый на 16 бит, второй на 32 бита. Другие мультиплексоры с бОльшим выбором мне не понадобились, пусть я их и реализовывал в начале работы над лабораторной.

Входы: D0, D1, COND
Выход: RES

COND=0  =>  возвращается D0
COND=1  =>  возвращается 

Просто использую 4 транизстора: 2 N-типа, 2 P-типа. Каждый вход пускаю по N-типу и P-типу, в затворы правильным образом передаю значения либо COND либо NOT COND. Так гарантирую, что транзисторы пропустят либо только D0, либо только D1, и в конце замыкаю провода и вставляю в RES.

**Счетчик**

Использую память на 8 бит по фронту. Этого диапозона значений для счетчика хватит, он не переполнится. 

Два входа: CLK, ENABLE, в которые передаются соответствующие значения с основном схемы.

Изначально в памяти внутреннее состоянии будет 0. При этом выход памяти используется и считается текущее значение + 1, которое замыкаем на вход данных памяти. При ENABLE включенном и CLK переходящем 0->1 получим обновление внутреннего состояния памяти.

Далее эта идея будет использоваться в подсчете корня из мантиссы.

Получается, что спустя небольшое epsilon после начала 1 такта значение counter перейдет в 1, далее будет таковым до начала 2 такта. Спустя небольшое epsilon после начала 2 такта counter обновится в число 2. И т.д.

**Left shifter**

На вход подается 32 битное число VAL и 5 битное число SHIFT, на значение которого сдвинем VAL.

Все просто: подряд стоят 5 мультиплексоров и на каждый бит значения SHIFT мы было сдвигаем на 1/2/4/8/16 бит либо не сдвигаем.

**Input parser**

Просто разбивает входное 16 битное число half precision на sign, exp, mant а так же выявляет следующие характеристики: IS_ZERO, IS_DENORM, IS_NAN, IS_INF.

(все тривиально, пишу коротко, чтобы вам много не читать)

**Special case handler**

Принимает на вход SIGN, IS_ZERO_INP, IS_NAN_INP, IS_INF_INP (всё из предыдущей схемы, не нужен лишь IS_DENORM, это пригодится позже), а также принимает всё изначальное число целиком. Он выявляет, является ли значение крайним случаем, и если является, то ставит соответствующий флаг BYPASS_CORE=1 (то есть можно сразу возвращать ответ), правильно формирует флаги IS_PINF, IS_NINF, IS_NAN (которые сразу передадутся в соотв флаги основном схемы), а также формирует значение SPECIAL_OUT (если действительно крайний случай), что будет являться ответом и что мы вернем.

**Get exp mant**

Прогоняет полученные в input parser значения экспоненты и мантиссы в одно из схем get_exp_mant_norm или get_exp_mant_denorm в зависимости от того, является ли входное число денормальным (флаг IS_DENORM пригодился тут).

Происходит в этих двух схемах то, что описывалось в теоретических обоснованиях: специальным образом преобразуется экспонента и сразу получаем экспоненту результата, а в зависимости от преобразований экспоненты и нормальности числа преобразуется мантисса, из которой позже будем брать корень.

Обе эти схемы возвращают преобразованную мантиссу в 16 бит и итоговую экспоненту в 5 бит.

**Get exp mant norm**

К мантиссе приписываем единицу на 10 бите (начиная с 0). Сдвигаем экспоненту на 1 бит влево, если входная экспонента нечетная. И если она четная, вычитаем из нее единицу. Потом делим на 2 и прибавляем 8 (в схемах прибавляю на 16 и делю на 2).

**Get exp mant denorm**

Нахожу, на сколько бит нужно сдвинуть мантиссу влево, чтобы старшая единица встала на 10 бит (используется highest_bit_16bits). Назовем это число mant_shift. Тогда структурно будет что то по типу следующего:

```cpp
exp = mant_shift;
is_exp_odd = exp % 2; // используем позже для сдвига mant
exp = 2 * exp + is_exp_odd; // сделали четным
exp = 8 - exp;
```
И если is_exp_odd верно, то мы сдвигаем мантиссу на 1 бит влево.

**Взятие корня**



**Assemble answer**

Просто принимает на вход итоговые мантиссу и экспоненту, собирает ответ с помощью сплиттеров.

### Verilog

> Раздел, в котором вы описываете свою реализацию:
> 
> Что за схема вам дана, как она работает.
> 
> Как она была реализована (как "под капотом" работает ваша схема).
> 
> Если в вашей схеме реализованы также (де)мультиплексоры, триггеры и прочие непростые логических схемы, то нужно также расписать как они работают и зачем были использованы (коротко: что это такое и принцип работы, можно приводить таблицы истинности и временные диаграммы).
> 
> Нужно описать как работают входовыходы.
> 
> Отдельно описать особенности сборки на Logisim, отдельно – на SystemVerilog.
>
> Какие конструкции Logisim использовались в работе и почему? Особенно это важно в реализации.
> Какие конструкции Verilog использовались в работе и почему? Особенно это важно в реализации.
>
> Все схемы должны работать одинаково!! Поэтому в отчёте должно быть раскрыто, как разботает каждая схема и доказательство, что поведение у них одинаковое.

### Примечания по оформлению (можно удалить после создания отчёта)

1. Не нужно вставлять своё описание как quote (цитату).
2. Старайтесь также разбивать ваш текст на логические разделы и отделять мысли заголовками.
3. Если хочется вставить фрагменты кода, то делаете это блоком кода. Если же ссылаетесь на код, то рекомендуется это делать через permalink на файлы в репозитории.
4. Можно пользоваться всеми возможностями Github Markdown.
5. Никаких фоток в отчёте, ровно как и скринов полного экрана. Это больно смотреть \(
6. Если вы хотите вставить изображение из сети, то не нужно его грузить в репозиторий.
7. В случае описание подсхем Logisim, если вы просто ссылаетесь на подсхему в целом, то достаточно указать назвнаие подсхемы из проекта. Если же вы описываете какой-то небольшой фрагмент схемы, то лучше его вставить в виде рисунка в отчёт.
