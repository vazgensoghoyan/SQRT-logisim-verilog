| Лабораторная работа №2     |  24Б10                      | Архитектура компьютера |
| :------------------------- | --------------------------- | ---------------------- |
| Построение логических схем | Согоян Вазген Айкович       | 2025 ноябрь            |

# Файл с заданием

[Тут](lab2_Circuits_november2025.pdf), файл lab2_Circuits_november2025.pdf!

# Инструментарий

Выполнив команду icarus -V узнаю, что использую следующую версию:
Icarus Verilog version 12.0 (stable)

# Выполнено

Реализована схема вычисления квадратного корня для чисел half precision (16 бит) с использованием Logisim-evolution и SystemVerilog.

- В Logisim собраны все основные подсхемы: сумматоры, триггеры (RS и D, включая по фронту), блоки памяти (2–32 бита), мультиплексоры 2→1 (16 и 32 бит), шифтер, подсхемы нахождения старшего бита, счётчик для итерационного вычисления корня, разбор входного числа (input_parser), обработка специальных случаев (special_case_handler), нормализация экспоненты и мантиссы (get_exp_mant_norm/denorm), итерационный блок вычисления корня (calc_sqrt) и сборка итогового ответа (assemble_answer).

- В SystemVerilog реализованы аналогичные функциональные блоки в поведенческой модели: разбор входного числа, обработка специальных случаев, нормализация экспоненты и мантиссы, итерационное вычисление корня, сборка ответа и управление флагами результата.

- Создан testbench для проверки корректности работы модуля, включая запись промежуточных значений и флагов.

# Теоретические обоснования

Назовем крайними случаями следующие входы:
- $\sqrt{+\infty} = +\infty$
- $\sqrt{-\infty} = \mathrm{qNaN}$
- $\sqrt{\text{-nonzero}} = \mathrm{qNaN}$
- $\sqrt{\pm 0} = \pm 0$
- $\sqrt{\mathrm{NaN}}$ = тот же NaN, но «утихомиренный»

В любом другом случае на вход получаем положительное число x: +0 < x < +inf.
Оно может быть денорм или норм.
Рассмотрим корень из минимального денорм числа:
$\sqrt{2^{-24}} = 2^{-12}$ - нормальное. Это хорошо. Для любого некрайнего случая ответ нормальный.

Поймем следующий факт: 
Старшая единица числа M на 10 бите (начиная с нуля) <=> старшая единица числа M^2 на 20 или 21 бите.
Так как 
$$
2^{10} \le M < 2^{11}
\;\Longleftrightarrow\;
2^{20} \le M^2 < 2^{22}
$$


1. Нормальное число

$ 1.M \cdot 2^{E-15} $ - фактическое число, которое записано в half precision как 0EM (E - 5 бит, M - 10 бит).

$$
\sqrt{1.M \cdot 2^{E-15}} =
\sqrt{1.M}\cdot 2^{(E-15)/2} =
\sqrt{1.M}\cdot 2^{(E+15)/2 - 15}
$$

Тогда если E будет четно, мы вычтем из E единицу и сдвигаем мантиссу. И все хорошо. 

Экспонента результата (сдвинутая) будет иметь вид (E-1)/2 + 8

Мантиссу результата считаем так:
- приписываем 10 нулей в конец числа
- получаем число длиной 21-22 бита
- берем корень итеративно из этого число
- получаем число длиной 11 бит, старшая единица попадает в старшее место
- убираем старшую единицы и эти 10 бит записываем в мантиссу ответа

2. Денормальное число

$ 0.M \cdot 2^{-14} = M \cdot 2^{-24} $ - фактическое число.

Нормализуем экспоненту и мантиссу.
Возвращаясь в структурное программирование, алгоритм действий таков:
```cpp
e = 1;
while (10 бит (начиная с нуля) равен 0) {
    m <<= 1;
    e--;
}
```

Чтобы всегда оставаться в unsigned числах, делаю я чуть другое.
- в схемах нахожу место старшего бита мантиссы (создал специальную схему для этого, легко)
- рассчитываю, насколько сдвинуть мантиссу нужно - пусть будет shift
  - то есть для мантиссы 0010010110 нужно получить 10010110000
  - в данном случае shift = 3, а старшая единица изначально была на месте 7
- экспонента итоговая будет равна 8 - shift/2
- тогда нужно держать shift четным:
  - если shift нечетный, то прибавим в shift единицу и сдвинем мантиссу влево
- мантиссу считем так же: приписываем 10 нулей и берем корень

### Logisim

**REMARK**

В схемах старался использовать PROBE с подписями, TUNNEL и иногда даже сами элементы/подсхемы в местах, где их использовал, подписывать, чтобы были как бы "комментарии" на схеме, то есть что и для чего делается. Надеюсь, хоть в какой то степени у меня получилось.

**sum**

Реализованы полные сумматоры чисел 1битных, 2, 4, 8, 16, 32 (через друг друга).

**memory**

Реализован синхронный RS триггер. Так же, как рассматривали на лекции. При этом добавлен еще один вход ENABLE: когда он равен 1, триггер работает как должен. При ENABLE=0 внутреннее состояние триггера сбрасывается в 0, изменения остальных входов ни на что не влияет.

Далее реализовал обычный D триггер, то есть работающий по уровню. После этого, подключив два D триггера подряд, получил триггер, работающий по фронту. Все это реализовано стандратно, просто с дополнительным входом ENABLE, который просто подключается в RS триггер.

Далее реализовано блоки памяти в 2, 4, 8, 16, 32 бита (через друг друга). Эти блоки памяти созданы по два, один по уровню, второй по фронту (почти везде нужно по фронту, но в одном месте пригодилось по уровню).

При этом ENABLE в памяти работаем асинхронно (кажется, я ничего не путаю и использую правильное слово). То перевод ENABLE из 1 в 0 или из 0 в 1 можно никак не синхронизировать с CLK и все будет корректно работать. 

**нахождение старшего бита**

Эти подсхемы назвал highest bit, не знаю, как правильно это называть. Они есть на входы 2 бита, 4, 8, 16, вновь большие сделаны через меньшие.

На 2 бита реализован просто: банально возвращает второй бит. То есть след смысл: когда ответ 0, значит, что старший бит на 0 месте, а когда 1, значит старшим на месте 1 (то есть на втором бите).

На 4 бита разбиваем их на 2 старших и 2 младших, считая для каждой пары место их старшего бита. Тогда если 2 старших бита сами по себе равны 0, то возвращаем ответ на 2 младших, иначе возвращаем ответ на 2 старших, к которому прибавили число 2 (тут, конечно, используется мультиплексор, о чем ниже).

На большее колво битов делается так же.

**Мультиплексоры**

У меня реализовано лишь два мультиплексора, оба реализуют выбор лишь между двумя значениями. Первый на 16 бит, второй на 32 бита. Другие мультиплексоры с бОльшим выбором мне не понадобились, пусть я их и реализовывал в начале работы над лабораторной.

Входы: D0, D1, COND
Выход: RES

COND=0  =>  возвращается D0
COND=1  =>  возвращается 

Просто использую 4 транизстора: 2 N-типа, 2 P-типа. Каждый вход пускаю по N-типу и P-типу, в затворы правильным образом передаю значения либо COND либо NOT COND. Так гарантирую, что транзисторы пропустят либо только D0, либо только D1, и в конце замыкаю провода и вставляю в RES.

**Счетчик**

Использую память на 8 бит по фронту. Этого диапозона значений для счетчика хватит, он не переполнится. 

Два входа: CLK, ENABLE, в которые передаются соответствующие значения с основном схемы.

Изначально в памяти внутреннее состоянии будет 0. При этом выход памяти используется и считается текущее значение + 1, которое замыкаем на вход данных памяти. При ENABLE включенном и CLK переходящем 0->1 получим обновление внутреннего состояния памяти.

Далее эта идея будет использоваться в подсчете корня из мантиссы.

Получается, что спустя небольшое epsilon после начала 1 такта значение counter перейдет в 1, далее будет таковым до начала 2 такта. Спустя небольшое epsilon после начала 2 такта counter обновится в число 2. И т.д.

**Left shifter**

На вход подается 32 битное число VAL и 5 битное число SHIFT, на значение которого сдвинем VAL.

Все просто: подряд стоят 5 мультиплексоров и на каждый бит значения SHIFT мы было сдвигаем на 1/2/4/8/16 бит либо не сдвигаем.

**Input parser**

Просто разбивает входное 16 битное число half precision на sign, exp, mant а так же выявляет следующие характеристики: IS_ZERO, IS_DENORM, IS_NAN, IS_INF.

(все тривиально, пишу коротко, чтобы вам много не читать)

**Special case handler**

Принимает на вход SIGN, IS_ZERO_INP, IS_NAN_INP, IS_INF_INP (всё из предыдущей схемы, не нужен лишь IS_DENORM, это пригодится позже), а также принимает всё изначальное число целиком. Он выявляет, является ли значение крайним случаем, и если является, то ставит соответствующий флаг BYPASS_CORE=1 (то есть можно сразу возвращать ответ), правильно формирует флаги IS_PINF, IS_NINF, IS_NAN (которые сразу передадутся в соотв флаги основном схемы), а также формирует значение SPECIAL_OUT (если действительно крайний случай), что будет являться ответом и что мы вернем.

**Get exp mant**

Прогоняет полученные в input parser значения экспоненты и мантиссы в одно из схем get_exp_mant_norm или get_exp_mant_denorm в зависимости от того, является ли входное число денормальным (флаг IS_DENORM пригодился тут).

Происходит в этих двух схемах то, что описывалось в теоретических обоснованиях: специальным образом преобразуется экспонента и сразу получаем экспоненту результата, а в зависимости от преобразований экспоненты и нормальности числа преобразуется мантисса, из которой позже будем брать корень.

Обе эти схемы возвращают преобразованную мантиссу в 16 бит и итоговую экспоненту в 5 бит.

**Get exp mant norm**

К мантиссе приписываем единицу на 10 бите (начиная с 0). Сдвигаем мантиссу на 1 бит влево, если входная экспонента четная. И если она четная, вычитаем из нее единицу. Потом делим на 2 и прибавляем 8 (в схемах прибавляю на 16 и делю на 2).

**Get exp mant denorm**

Нахожу, на сколько бит нужно сдвинуть мантиссу влево, чтобы старшая единица встала на 10 бит (используется highest_bit_16bits). Назовем это число mant_shift. Тогда структурно будет что то по типу следующего:

```cpp
exp = mant_shift;
is_exp_odd = exp % 2; // используем позже для сдвига mant
exp = 2 * exp + is_exp_odd; // сделали четным
exp = 8 - exp;
```
И если is_exp_odd верно, то мы сдвигаем мантиссу на 1 бит влево.

**Взятие корня**

Получем на вход нормализованную мантиссу и дописываем к ней справа 10 нулей (то есть сдвигаем влево на 10 бит).

Имеем блок памяти на 32 бита для хранения сдвинутой мантиссы (которая либо длины 21 бит, либо 22 бита). Туда, если мы на 2 такте, мы записываем входную мантиссу, к котрой приписали 10 нулей. Если мы на 3 или более такте, то записываем в память другое значение (мы в цикле, мантисса уменьшается либо не изменяется, так как мы всегда пытаемся из нее что то вычесть в вычислении в столбик).

Есть еще блок памяти на 16 бит. Там хранится результат - посчитанный корень. Он начинается с 0 (как и любая память в моей лабораторной), потом рекурсивно к ней справа приписываются нули и единицы. Это делается пока мы не дойдем до момента, что в памяти записано число со старшей единицей на 10 бите (то есть число длины 11). Тогда мы останавливаем вычисление, то есть стабилизируем память с результатом, ставим флаг RESULT=1.

Remark: корректность всего этого и похожих моментов, что есть в других подсхемах, я описывал в теор обоснованиях.

В цикле происходит следующее:
- к текущему значению результата (из памяти) приписываем 01
- сдвигаем это на 26 - counter * 2 влево (как бы приходим к нужной паре битиков мантиссы в подсчете в столбик)
- сдвигаем на это число
- проверяем, является ли оно меньшим либо равным значения в памяти, отведенной мантиссе
- если да:
  - к answer на след такте припишем 1
  - мантиссу (из нее берем корень) уменьшим на это число (то же действие, что в столбик)
- иначе:
  - к answer припишем 0

**Assemble answer**

Просто принимает на вход итоговые мантиссу и экспоненту, собирает ответ с помощью сплиттеров.

**Основная sqrt схема**

Схема визуально как бы разбита на несколько блоков (а на самом деле они связаны с помощью тунелей).

1. Часть с счетчиком. 

Подключена подсхема счетчика, куда передаются ENABLE и CLK. Выходное значение нужно для подсчета корня мантиссы, а так же мы его используем для своего рода синхронизации, подсчитываются два значения: counter_not_zero и second_or_more_tact. Первое - счетчик не ноль, то есть больше или равен 1 (это верно с первого такта и далее пока enable=1). Второе - счетчик больше или равен 2 (это верно со второго такта и далее пока enable=1).

2. Входные данные. 

IO_DATA_IN входит в шину DATA_IN. CLK и ENABLE через туннели передаются по всей схеме куда надо (CLK используется дважды, ENABLE трижды).

3. Начальная обработка входных данных. 

Имеем память в 16 бит, работающую по фронту по значению counter_not_zero. И в данные передается туннель DATA_IN. То есть действительно пока данные на 1 такте передается, через небольшое epsilon после начала 1 такта данные запишутся в память и пока enable=1 никак не будут в памяти меняться.

Значение из памяти передается в input_parser. Оттуда распределяются в special_case_handler.

4. Продолжение обработки входных данных.

Из input_parser через туннели получаем распарсенные мантиссу и экспоненту. Нормализуем их благодаря подсхеме get_exp_mant (название первое пришедшее в голову, не совсем подходящее). Тут мы получаем итоговую экспоненту, а нормализованную мантиссу передает в подсхему, считающую из нее корень.

5. Сбор ответа

Итоговую экспоненту и корень мантиссы (либо промежуточное значение алгоритма) из предыдущего пункта мы с помощью подсхемы assemble_answer собираем и делаем if-else: если BYPASS_CORE, то возвращаем SPECIAL_OUT, иначе то, что собрали из посчитанных экспоненты и корня мантиссы.

6. Выходные данные.

Флаги IS_NAN, IS_PINF, IS_NINF мы берем из выхода special_case_handler. RESULT является результатом операции ИЛИ над BYPASS_CORE из special_case_handler и одноименного флага result из схемы для подсчета корня мантиссы.

На IO_DATA_OUT подается значение из туннеля ANSWER (выходное значение предыдущего пункта). Но подается только начиная со 2 такта, на 1 такте там высокоимпедансное состояние (реализовано с помощью двух транзисторов).

### Verilog

Тут не пришлось создавать модулей для памяти, для мультиплексоров, для левого сдвига, для нахождения старшего бита, для сумматоров.

Все остальные подсхемы, которые есть в logisim, тут созданы.

**input_parser**

Делает то же, что описывал выше. Просто правильно делаю assign-ы.

**special_case_handler**

Правильно делает assign-ы на флаги. А SPECIAL_OUT сделал reg, куда в always записываю нужное значения в зависимости от флагов, знака и данного изначально числа.

**counter**

Почти такой же, как в logisim. Но тут он синхронный, а там асинхронный относительно ENABLE (надеюсь, правильно выразился). То есть тут при ENABLE 1->0 он сбросит значение только про CLK 0->1.

**get_exp_mant**

Используя модули get_exp_mant_norm, get_exp_mant_denorm в зависимости от флага IS_DENORM возвращает нужные значения.

**get_exp_mant_norm**

Делает то, что описывал в теор части.

**get_exp_mant_denorm**

Делает то, что описывал в теор части.

**calc_sqrt**

Повторяю работу из Losigim. 

Записываем значение в локальную память только при CLK 0->1 и COUNTER==2. Записываем мы мантиссу, к которой приписали 10 нулей. Далее считаем корень итерационно, код повторяет теор часть.

Здесь вычисление заканчивается (точнее память перестает изменяться) не при условии, что на 10 бит результата встала единица, как в logisim. Тут иначе: имеем счетчик, которые начинает изменяться при записи в answer, то есть когда память уже записана и на след такт начинается само итерационное вычисление корня из того, что записано в память. Когда счетчик становится равным 11, более изменений мы не делаем.

**testbanch**

В sqrt2_log.txt записываю номер теста, входное число, далее все промежуточные значения, которые выводятся. И в конце итоговый результат со всеми флагами после RESULT=1. И ожидаемое значение.

# Спасибо!
